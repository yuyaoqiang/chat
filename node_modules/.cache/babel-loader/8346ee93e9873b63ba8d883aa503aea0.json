{"ast":null,"code":"module.exports = {\n  isNotUTF8: isNotUTF8,\n  getCharLength: getCharLength,\n  getCharCode: getCharCode,\n  getStringFromBytes: getStringFromBytes,\n  getBytesForCharCode: getBytesForCharCode,\n  setBytesFromCharCode: setBytesFromCharCode,\n  setBytesFromString: setBytesFromString\n}; // non UTF8 encoding detection (cf README file for details)\n\nfunction isNotUTF8(bytes, byteOffset, byteLength) {\n  try {\n    getStringFromBytes(bytes, byteOffset, byteLength, true);\n  } catch (e) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getCharLength(theByte) {\n  // 4 bytes encoded char (mask 11110000)\n  if (0xf0 == (theByte & 0xf0)) {\n    return 4; // 3 bytes encoded char (mask 11100000)\n  } else if (0xe0 == (theByte & 0xe0)) {\n    return 3; // 2 bytes encoded char (mask 11000000)\n  } else if (0xc0 == (theByte & 0xc0)) {\n    return 2; // 1 bytes encoded char\n  } else if (theByte == (theByte & 0x7f)) {\n    return 1;\n  }\n\n  return 0;\n} // UTF8 decoding functions\n\n\nfunction getCharCode(bytes, byteOffset, charLength) {\n  var charCode = 0,\n      mask = '';\n  byteOffset = byteOffset || 0; // validate that the array has at least one byte in it\n\n  if (bytes.length - byteOffset <= 0) {\n    throw new Error('No more characters remaining in array.');\n  } // Retrieve charLength if not given\n\n\n  charLength = charLength || getCharLength(bytes[byteOffset]);\n\n  if (charLength == 0) {\n    throw new Error(bytes[byteOffset].toString(2) + ' is not a significative' + ' byte (offset:' + byteOffset + ').');\n  } // Return byte value if charlength is 1\n\n\n  if (1 === charLength) {\n    return bytes[byteOffset];\n  } // validate that the array has enough bytes to make up this character\n\n\n  if (bytes.length - byteOffset < charLength) {\n    throw new Error('Expected at least ' + charLength + ' bytes remaining in array.');\n  } // Test UTF8 integrity\n\n\n  mask = '00000000'.slice(0, charLength) + 1 + '00000000'.slice(charLength + 1);\n\n  if (bytes[byteOffset] & parseInt(mask, 2)) {\n    throw Error('Index ' + byteOffset + ': A ' + charLength + ' bytes' + ' encoded char' + ' cannot encode the ' + (charLength + 1) + 'th rank bit to 1.');\n  } // Reading the first byte\n\n\n  mask = '0000'.slice(0, charLength + 1) + '11111111'.slice(charLength + 1);\n  charCode += (bytes[byteOffset] & parseInt(mask, 2)) << --charLength * 6; // Reading the next bytes\n\n  while (charLength) {\n    if (0x80 !== (bytes[byteOffset + 1] & 0x80) || 0x40 === (bytes[byteOffset + 1] & 0x40)) {\n      throw Error('Index ' + (byteOffset + 1) + ': Next bytes of encoded char' + ' must begin with a \"10\" bit sequence.');\n    }\n\n    charCode += (bytes[++byteOffset] & 0x3f) << --charLength * 6;\n  }\n\n  return charCode;\n}\n\nfunction getStringFromBytes(bytes, byteOffset, byteLength, strict) {\n  var charLength,\n      chars = [];\n  byteOffset = byteOffset | 0;\n  byteLength = 'number' === typeof byteLength ? byteLength : bytes.byteLength || bytes.length;\n\n  for (; byteOffset < byteLength; byteOffset++) {\n    charLength = getCharLength(bytes[byteOffset]);\n\n    if (byteOffset + charLength > byteLength) {\n      if (strict) {\n        throw Error('Index ' + byteOffset + ': Found a ' + charLength + ' bytes encoded char declaration but only ' + (byteLength - byteOffset) + ' bytes are available.');\n      }\n    } else {\n      chars.push(String.fromCodePoint(getCharCode(bytes, byteOffset, charLength, strict)));\n    }\n\n    byteOffset += charLength - 1;\n  }\n\n  return chars.join('');\n} // UTF8 encoding functions\n\n\nfunction getBytesForCharCode(charCode) {\n  if (charCode < 128) {\n    return 1;\n  } else if (charCode < 2048) {\n    return 2;\n  } else if (charCode < 65536) {\n    return 3;\n  } else if (charCode < 2097152) {\n    return 4;\n  }\n\n  throw new Error('CharCode ' + charCode + ' cannot be encoded with UTF8.');\n}\n\nfunction setBytesFromCharCode(charCode, bytes, byteOffset, neededBytes) {\n  charCode = charCode | 0;\n  bytes = bytes || [];\n  byteOffset = byteOffset | 0;\n  neededBytes = neededBytes || getBytesForCharCode(charCode); // Setting the charCode as it to bytes if the byte length is 1\n\n  if (1 == neededBytes) {\n    bytes[byteOffset] = charCode;\n  } else {\n    // Computing the first byte\n    bytes[byteOffset++] = (parseInt('1111'.slice(0, neededBytes), 2) << 8 - neededBytes) + (charCode >>> --neededBytes * 6); // Computing next bytes\n\n    for (; neededBytes > 0;) {\n      bytes[byteOffset++] = charCode >>> --neededBytes * 6 & 0x3f | 0x80;\n    }\n  }\n\n  return bytes;\n}\n\nfunction setBytesFromString(string, bytes, byteOffset, byteLength, strict) {\n  string = string || '';\n  bytes = bytes || [];\n  byteOffset = byteOffset | 0;\n  byteLength = 'number' === typeof byteLength ? byteLength : bytes.byteLength || Infinity;\n\n  for (var i = 0, j = string.length; i < j; i++) {\n    var neededBytes = getBytesForCharCode(string[i].codePointAt(0));\n\n    if (strict && byteOffset + neededBytes > byteLength) {\n      throw new Error('Not enought bytes to encode the char \"' + string[i] + '\" at the offset \"' + byteOffset + '\".');\n    }\n\n    setBytesFromCharCode(string[i].codePointAt(0), bytes, byteOffset, neededBytes, strict);\n    byteOffset += neededBytes;\n  }\n\n  return bytes;\n}","map":{"version":3,"sources":["/Users/yuanfang/Downloads/Telegram Desktop/封存/advisory-h5/node_modules/utf-8/src/UTF8.js"],"names":["module","exports","isNotUTF8","getCharLength","getCharCode","getStringFromBytes","getBytesForCharCode","setBytesFromCharCode","setBytesFromString","bytes","byteOffset","byteLength","e","theByte","charLength","charCode","mask","length","Error","toString","slice","parseInt","strict","chars","push","String","fromCodePoint","join","neededBytes","string","Infinity","i","j","codePointAt"],"mappings":"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","sourcesContent":["module.exports = {\n  isNotUTF8: isNotUTF8,\n  getCharLength: getCharLength,\n  getCharCode: getCharCode,\n  getStringFromBytes: getStringFromBytes,\n  getBytesForCharCode: getBytesForCharCode,\n  setBytesFromCharCode: setBytesFromCharCode,\n  setBytesFromString: setBytesFromString,\n};\n\n// non UTF8 encoding detection (cf README file for details)\nfunction isNotUTF8(bytes, byteOffset, byteLength) {\n  try {\n    getStringFromBytes(bytes, byteOffset, byteLength, true);\n  } catch (e) {\n    return true;\n  }\n  return false;\n}\n\nfunction getCharLength(theByte) {\n  // 4 bytes encoded char (mask 11110000)\n  if (0xf0 == (theByte & 0xf0)) {\n    return 4;\n    // 3 bytes encoded char (mask 11100000)\n  } else if (0xe0 == (theByte & 0xe0)) {\n    return 3;\n    // 2 bytes encoded char (mask 11000000)\n  } else if (0xc0 == (theByte & 0xc0)) {\n    return 2;\n    // 1 bytes encoded char\n  } else if (theByte == (theByte & 0x7f)) {\n    return 1;\n  }\n  return 0;\n}\n\n// UTF8 decoding functions\nfunction getCharCode(bytes, byteOffset, charLength) {\n  var charCode = 0,\n    mask = '';\n  byteOffset = byteOffset || 0;\n  // validate that the array has at least one byte in it\n  if (bytes.length - byteOffset <= 0) {\n    throw new Error('No more characters remaining in array.');\n  }\n  // Retrieve charLength if not given\n  charLength = charLength || getCharLength(bytes[byteOffset]);\n  if (charLength == 0) {\n    throw new Error(\n      bytes[byteOffset].toString(2) +\n        ' is not a significative' +\n        ' byte (offset:' +\n        byteOffset +\n        ').'\n    );\n  }\n  // Return byte value if charlength is 1\n  if (1 === charLength) {\n    return bytes[byteOffset];\n  }\n  // validate that the array has enough bytes to make up this character\n  if (bytes.length - byteOffset < charLength) {\n    throw new Error(\n      'Expected at least ' + charLength + ' bytes remaining in array.'\n    );\n  }\n  // Test UTF8 integrity\n  mask = '00000000'.slice(0, charLength) + 1 + '00000000'.slice(charLength + 1);\n  if (bytes[byteOffset] & parseInt(mask, 2)) {\n    throw Error(\n      'Index ' +\n        byteOffset +\n        ': A ' +\n        charLength +\n        ' bytes' +\n        ' encoded char' +\n        ' cannot encode the ' +\n        (charLength + 1) +\n        'th rank bit to 1.'\n    );\n  }\n  // Reading the first byte\n  mask = '0000'.slice(0, charLength + 1) + '11111111'.slice(charLength + 1);\n  charCode += (bytes[byteOffset] & parseInt(mask, 2)) << (--charLength * 6);\n  // Reading the next bytes\n  while (charLength) {\n    if (\n      0x80 !== (bytes[byteOffset + 1] & 0x80) ||\n      0x40 === (bytes[byteOffset + 1] & 0x40)\n    ) {\n      throw Error(\n        'Index ' +\n          (byteOffset + 1) +\n          ': Next bytes of encoded char' +\n          ' must begin with a \"10\" bit sequence.'\n      );\n    }\n    charCode += (bytes[++byteOffset] & 0x3f) << (--charLength * 6);\n  }\n  return charCode;\n}\n\nfunction getStringFromBytes(bytes, byteOffset, byteLength, strict) {\n  var charLength,\n    chars = [];\n  byteOffset = byteOffset | 0;\n  byteLength =\n    'number' === typeof byteLength\n      ? byteLength\n      : bytes.byteLength || bytes.length;\n  for (; byteOffset < byteLength; byteOffset++) {\n    charLength = getCharLength(bytes[byteOffset]);\n    if (byteOffset + charLength > byteLength) {\n      if (strict) {\n        throw Error(\n          'Index ' +\n            byteOffset +\n            ': Found a ' +\n            charLength +\n            ' bytes encoded char declaration but only ' +\n            (byteLength - byteOffset) +\n            ' bytes are available.'\n        );\n      }\n    } else {\n      chars.push(\n        String.fromCodePoint(getCharCode(bytes, byteOffset, charLength, strict))\n      );\n    }\n    byteOffset += charLength - 1;\n  }\n  return chars.join('');\n}\n\n// UTF8 encoding functions\nfunction getBytesForCharCode(charCode) {\n  if (charCode < 128) {\n    return 1;\n  } else if (charCode < 2048) {\n    return 2;\n  } else if (charCode < 65536) {\n    return 3;\n  } else if (charCode < 2097152) {\n    return 4;\n  }\n  throw new Error('CharCode ' + charCode + ' cannot be encoded with UTF8.');\n}\n\nfunction setBytesFromCharCode(charCode, bytes, byteOffset, neededBytes) {\n  charCode = charCode | 0;\n  bytes = bytes || [];\n  byteOffset = byteOffset | 0;\n  neededBytes = neededBytes || getBytesForCharCode(charCode);\n  // Setting the charCode as it to bytes if the byte length is 1\n  if (1 == neededBytes) {\n    bytes[byteOffset] = charCode;\n  } else {\n    // Computing the first byte\n    bytes[byteOffset++] =\n      (parseInt('1111'.slice(0, neededBytes), 2) << (8 - neededBytes)) +\n      (charCode >>> (--neededBytes * 6));\n    // Computing next bytes\n    for (; neededBytes > 0; ) {\n      bytes[byteOffset++] = ((charCode >>> (--neededBytes * 6)) & 0x3f) | 0x80;\n    }\n  }\n  return bytes;\n}\n\nfunction setBytesFromString(string, bytes, byteOffset, byteLength, strict) {\n  string = string || '';\n  bytes = bytes || [];\n  byteOffset = byteOffset | 0;\n  byteLength =\n    'number' === typeof byteLength ? byteLength : bytes.byteLength || Infinity;\n  for (var i = 0, j = string.length; i < j; i++) {\n    var neededBytes = getBytesForCharCode(string[i].codePointAt(0));\n    if (strict && byteOffset + neededBytes > byteLength) {\n      throw new Error(\n        'Not enought bytes to encode the char \"' +\n          string[i] +\n          '\" at the offset \"' +\n          byteOffset +\n          '\".'\n      );\n    }\n    setBytesFromCharCode(\n      string[i].codePointAt(0),\n      bytes,\n      byteOffset,\n      neededBytes,\n      strict\n    );\n    byteOffset += neededBytes;\n  }\n  return bytes;\n}\n"]},"metadata":{},"sourceType":"script"}