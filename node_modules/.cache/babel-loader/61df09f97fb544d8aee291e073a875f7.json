{"ast":null,"code":"/*jslint node: true */\n\"use strict\";\n\nvar assert = require('assert');\n\nvar fs = require('fs');\n\nvar util = require('util');\n\nvar BufferExtender = require('./Buffer'); // bad idea\n\n\nvar debug = require('debug')('exif');\n\nvar DEFAULT_MAX_ENTRIES = 128;\n/**\r\n * Represents an image with Exif information. When instantiating it you have to\r\n * provide an image and a callback function which is called once all metadata\r\n * is extracted from the image.\r\n *\r\n * Available options are:\r\n *  - image The image to get Exif data from can be either a filesystem path or\r\n *          a Buffer.\r\n *  - tiffOffsets  (boolean) an object named \"offsets\" is added to exifData \r\n *          and contains lot of offsets needed to get thumbnail and other things. \r\n *  - fixThumbnailOffset:  node-exif corrects the thumbnail offset in order to have an offset from the start of the buffer/file.\r\n *  - maxEntries: Specifies the maximum entries to be parsed\r\n *  - ifd0MaxEntries\r\n *  - ifd1MaxEntries\r\n *  - maxGpsEntries\r\n *  - maxInteroperabilityEntries\r\n *  - agfaMaxEntries \r\n *  - epsonMaxEntries\r\n *  - fujifilmMaxEntries\r\n *  - olympusMaxEntries\r\n *  - panasonicMaxEntries\r\n *  - sanyoMaxEntries\r\n *  - noPadding\r\n *\r\n * If you don't set the image field, you might call  exifImage.loadImage(image, callback) to get exif datas. \r\n *\r\n * @param options Configuration options as described above\r\n * @param callback Function to call when data is extracted or an error occurred\r\n * @return Nothing of importance, calls the specified callback function instead\r\n */\n\nfunction ExifImage(options, callback) {\n  if (!(this instanceof ExifImage)) {\n    if (typeof options === \"string\") {\n      options = {\n        image: options\n      };\n    }\n\n    assert(typeof options === \"object\", \"Invalid options object\");\n    var exifImage = new ExifImage(options, function (error, data) {\n      if (error) {\n        return callback(error);\n      }\n\n      callback(null, data, options.image);\n    });\n    return exifImage;\n  }\n\n  if (typeof options === \"string\") {\n    options = {\n      image: options\n    };\n  } else if (options instanceof Buffer) {\n    options = {\n      image: options\n    };\n  }\n\n  var ops = {};\n\n  if (options) {\n    for (var k in options) {\n      ops[k] = options[k];\n    }\n  }\n\n  this.options = ops; // Default option values\n\n  [\"ifd0MaxEntries\", \"ifd1MaxEntries\", \"maxGpsEntries\", \"maxInteroperabilityEntries\", \"agfaMaxEntries\", \"epsonMaxEntries\", \"fujifilmMaxEntries\", \"olympusMaxEntries\", \"panasonicMaxEntries\", \"sanyoMaxEntries\"].forEach(function (p) {\n    if (ops[p] === undefined) {\n      ops[p] = DEFAULT_MAX_ENTRIES;\n    }\n  });\n  this.exifData = {\n    image: {},\n    // Information about the main image\n    thumbnail: {},\n    // Information about the thumbnail\n    exif: {},\n    // Exif information\n    gps: {},\n    // GPS information\n    interoperability: {},\n    // Exif Interoperability information\n    makernote: {} // Makernote information\n\n  };\n  this.offsets = {};\n\n  if (ops.tiffOffsets) {\n    exifData.offsets = offsets;\n  }\n\n  debug(\"New ExifImage options=\", options);\n\n  if (!ops.image) {\n    // If options image is not specified, the developper must call loadImage() to parse the image.\n    //    callback(new Error('You have to provide an image, it is pretty hard to extract Exif data from nothing...'));\n    return;\n  }\n\n  if (typeof callback !== 'function') {\n    throw new Error('You have to provide a callback function.');\n  }\n\n  var self = this;\n  setImmediate(function () {\n    self.loadImage(ops.image, function (error, exifData) {\n      if (error) {\n        return callback(error);\n      }\n\n      callback(null, exifData, ops.image);\n    });\n  });\n}\n\nExifImage.ExifImage = ExifImage;\nmodule.exports = ExifImage;\n/**\r\n * Load image and parse exifDatas\r\n *\r\n * @param [String|Buffer] image the image\r\n * @param callback a callback which is called when exif datas are parsed.\r\n * @return Nothing\r\n */\n\nExifImage.prototype.loadImage = function (image, callback) {\n  assert(typeof callback === \"function\", \"Callback must be a function\");\n  var self = this;\n  debug(\"loadImage image=\", image);\n\n  if (image.constructor.name === 'Buffer') {\n    this.processImage(\"Buffer\", image, callback);\n    return;\n  }\n\n  if (image.constructor.name === 'String') {\n    fs.readFile(image, function (error, data) {\n      if (error) {\n        callback(new Error('Encountered the following error while trying to read given image: ' + error));\n        return;\n      }\n\n      self.processImage(\"File: \" + image, data, callback);\n    });\n    return;\n  }\n\n  callback(new Error('Given image is neither a buffer nor a file, please provide one of these.'));\n};\n\nExifImage.prototype.processImage = function (source, data, callback) {\n  assert(typeof source === \"string\", \"Source must be a string\");\n  assert(typeof callback === \"function\", \"Callback must be a function\");\n  var offset = 0;\n\n  if (data[offset++] != 0xFF || data[offset++] != 0xD8) {\n    var e = new Error('The given image is not a JPEG and thus unsupported right now.');\n    e.source = source;\n    e.code = \"NOT_A_JPEG\";\n    callback(e);\n    return;\n  }\n\n  this.imageType = 'JPEG';\n\n  while (offset < data.length) {\n    if (data[offset++] != 0xFF) {\n      break;\n    }\n\n    if (data[offset++] == 0xE1) {\n      try {\n        this.extractExifData(data, offset + 2, data.getShort(offset, true) - 2);\n      } catch (error) {\n        error.code = \"PARSING_ERROR\";\n        error.source = source;\n        debug(\"Extract exif data error source=\", source, \"offset=\", offset, \"error=\", error);\n        callback(error);\n        return;\n      }\n\n      debug(\"Extract exif data success source=\", source, \"exifData=\", this.exifData);\n      callback(null, this.exifData);\n      return;\n    }\n\n    offset += data.getShort(offset, true);\n  }\n\n  var e2 = new Error('No Exif segment found in the given image.');\n  e2.source = source;\n  e2.code = \"NO_EXIF_SEGMENT\";\n  callback(e2);\n};\n\nExifImage.prototype.extractExifData = function (data, start, length) {\n  var exifData = this.exifData;\n  var tiffOffset = start + 6;\n  var ifdOffset, numberOfEntries;\n  var noPadding = this.options.noPadding !== false;\n  this.offsets.tiff = tiffOffset; // Exif data always starts with Exif\\0\\0\n\n  if (data.toString('utf8', start, tiffOffset) != 'Exif\\0\\0') {\n    throw new Error('The Exif data is not valid.');\n  } // After the Exif start we either have 0x4949 if the following data is\n  // stored in big endian or 0x4D4D if it is stored in little endian\n\n\n  if (data.getShort(tiffOffset) == 0x4949) {\n    this.isBigEndian = false;\n  } else if (data.getShort(tiffOffset) == 0x4D4D) {\n    this.isBigEndian = true;\n  } else {\n    throw new Error('Invalid TIFF data! Expected 0x4949 or 0x4D4D at offset ' + tiffOffset + ' but found 0x' + data[tiffOffset].toString(16).toUpperCase() + data[tiffOffset + 1].toString(16).toUpperCase() + \".\");\n  }\n\n  debug(\"BigEndian=\", this.isBigEndian); // Valid TIFF headers always have 0x002A here\n\n  if (data.getShort(tiffOffset + 2, this.isBigEndian) != 0x002A) {\n    var expected = this.isBigEndian ? '0x002A' : '0x2A00';\n    throw new Error('Invalid TIFF data! Expected ' + expected + ' at offset ' + (tiffOffset + 2) + ' but found 0x' + data[tiffOffset + 2].toString(16).toUpperCase() + data[tiffOffset + 3].toString(16).toUpperCase() + \".\");\n  }\n  /********************************* IFD0 **********************************/\n  // Offset to IFD0 which is always followed by two bytes with the amount of\n  // entries in this IFD\n\n\n  ifdOffset = tiffOffset + data.getLong(tiffOffset + 4, this.isBigEndian);\n  this.offsets.ifd0 = ifdOffset;\n  numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);\n\n  if (this.options.ifd0MaxEntries) {\n    numberOfEntries = Math.min(numberOfEntries, this.options.ifd0MaxEntries);\n  }\n\n  debug(\"IFD0 ifdOffset=\", ifdOffset, \"numberOfEntries=\", numberOfEntries); // Each IFD entry consists of 12 bytes which we loop through and extract\n  // the data from\n\n  for (var i = 0; i < numberOfEntries; i++) {\n    var exifEntry = this.extractExifEntry(data, ifdOffset + 2 + i * 12, tiffOffset, this.isBigEndian, ExifImage.TAGS.exif);\n\n    if (!exifEntry) {\n      continue;\n    }\n\n    if (exifEntry.tagId === 0xEA1C && noPadding) {\n      continue;\n    }\n\n    exifData.image[exifEntry.tagName] = exifEntry.value;\n  }\n\n  debug(\"IFD0 parsed\", exifData.image);\n  /********************************* IFD1 **********************************/\n  // Check if there is an offset for IFD1. If so it is always followed by two\n  // bytes with the amount of entries in this IFD, if not there is no IFD1\n\n  var nextIfdOffset = data.getLong(ifdOffset + 2 + numberOfEntries * 12, this.isBigEndian);\n\n  if (nextIfdOffset != 0x00000000) {\n    ifdOffset = tiffOffset + nextIfdOffset;\n    this.offsets.ifd1 = ifdOffset;\n    numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);\n\n    if (this.options.ifd1MaxEntries) {\n      numberOfEntries = Math.min(numberOfEntries, this.options.ifd1MaxEntries);\n    }\n\n    debug(\"IFD1 ifdOffset=\", ifdOffset, \"numberOfEntries=\", numberOfEntries); // Each IFD entry consists of 12 bytes which we loop through and extract\n    // the data from\n\n    for (var i = 0; i < numberOfEntries; i++) {\n      var exifEntry = this.extractExifEntry(data, ifdOffset + 2 + i * 12, tiffOffset, this.isBigEndian, ExifImage.TAGS.exif);\n\n      if (!exifEntry) {\n        continue;\n      }\n\n      if (exifEntry.tagId === 0xEA1C && noPadding) {\n        continue;\n      }\n\n      exifData.thumbnail[exifEntry.tagName] = exifEntry.value;\n    }\n\n    if (this.options.fixThumbnailOffset) {\n      var thumbnailOffset = exifData.thumbnail[ExifImage.TAGS.exif[0x0201]];\n\n      if (thumbnailOffset) {\n        debug(\"IFD1 fix thumbnail offset, add=\", this.offsets.tiff);\n        exifData.thumbnail[ExifImage.TAGS.exif[0x0201]] += this.offsets.tiff;\n      }\n    }\n\n    debug(\"IFD1 parsed\", exifData.thumbnail);\n  }\n  /******************************* EXIF IFD ********************************/\n  // Look for a pointer to the Exif IFD in IFD0 and extract information from\n  // it if available\n\n\n  if (exifData.image[ExifImage.TAGS.exif[0x8769]]) {\n    ifdOffset = tiffOffset + exifData.image[ExifImage.TAGS.exif[0x8769]];\n    this.offsets.tags = ifdOffset;\n    numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);\n\n    if (this.options.maxEntries) {\n      numberOfEntries = Math.min(numberOfEntries, this.options.maxEntries);\n    }\n\n    debug(\"EXIF IFD ifdOffset=\", ifdOffset, \"numberOfEntries=\", numberOfEntries); // Each IFD entry consists of 12 bytes which we loop through and extract\n    // the data from\n\n    for (var i = 0; i < numberOfEntries; i++) {\n      var exifEntry = this.extractExifEntry(data, ifdOffset + 2 + i * 12, tiffOffset, this.isBigEndian, ExifImage.TAGS.exif);\n\n      if (!exifEntry) {\n        continue;\n      }\n\n      if (exifEntry.tagId === 0xEA1C && noPadding) {\n        continue;\n      }\n\n      exifData.exif[exifEntry.tagName] = exifEntry.value;\n    }\n\n    debug(\"EXIF IFD parsed\", exifData.exif);\n  }\n  /******************************** GPS IFD ********************************/\n  // Look for a pointer to the GPS IFD in IFD0 and extract information from\n  // it if available\n\n\n  if (exifData.image[ExifImage.TAGS.exif[0x8825]]) {\n    ifdOffset = tiffOffset + exifData.image[ExifImage.TAGS.exif[0x8825]];\n    this.offsets.gps = ifdOffset;\n    numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);\n\n    if (this.options.maxGpsEntries) {\n      numberOfEntries = Math.min(numberOfEntries, this.options.maxGpsEntries);\n    }\n\n    debug(\"GPS IFD ifdOffset=\", ifdOffset, \"numberOfEntries=\", numberOfEntries); // Each IFD entry consists of 12 bytes which we loop through and extract\n    // the data from\n\n    for (var i = 0; i < numberOfEntries; i++) {\n      var exifEntry = this.extractExifEntry(data, ifdOffset + 2 + i * 12, tiffOffset, this.isBigEndian, ExifImage.TAGS.gps);\n\n      if (!exifEntry) {\n        continue;\n      }\n\n      if (exifEntry.tagId === 0xEA1C && noPadding) {\n        continue;\n      }\n\n      exifData.gps[exifEntry.tagName] = exifEntry.value;\n    }\n\n    debug(\"GPS IFD parsed\", exifData.gps);\n  }\n  /************************* Interoperability IFD **************************/\n  // Look for a pointer to the interoperatbility IFD in the Exif IFD and\n  // extract information from it if available\n\n\n  if (exifData.exif[ExifImage.TAGS.exif[0xA005]]) {\n    ifdOffset = tiffOffset + exifData.exif[ExifImage.TAGS.exif[0xA005]];\n    this.offsets.interoperability = ifdOffset;\n    numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);\n\n    if (this.options.maxInteroperabilityEntries) {\n      numberOfEntries = Math.min(numberOfEntries, this.options.maxInteroperabilityEntries);\n    }\n\n    debug(\"Interoperability IFD ifdOffset=\", ifdOffset, \"numberOfEntries=\", numberOfEntries); // Each IFD entry consists of 12 bytes which we loop through and extract\n    // the data from\n\n    for (var i = 0; i < numberOfEntries; i++) {\n      var exifEntry = this.extractExifEntry(data, ifdOffset + 2 + i * 12, tiffOffset, this.isBigEndian, ExifImage.TAGS.exif);\n\n      if (!exifEntry) {\n        break;\n      }\n\n      if (exifEntry.tagId === 0xEA1C && noPadding) {\n        continue;\n      }\n\n      exifData.interoperability[exifEntry.tagName] = exifEntry.value;\n    }\n\n    debug(\"Interoperability IFD parsed\", exifData.gps);\n  }\n  /***************************** Makernote IFD *****************************/\n  // Look for Makernote data in the Exif IFD, check which type of proprietary\n  // Makernotes the image contains, load the respective functionality and\n  // start the extraction\n\n\n  if (typeof exifData.exif[ExifImage.TAGS.exif[0x927C]] != \"undefined\") {\n    var type; // Check the header to see what kind of Makernote we are dealing with\n\n    if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 7) === \"OLYMP\\x00\\x01\" || exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 7) === \"OLYMP\\x00\\x02\") {\n      type = \"olympus\";\n    } else if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 7) === \"AGFA \\x00\\x01\") {\n      type = \"agfa\";\n    } else if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 8) === \"EPSON\\x00\\x01\\x00\") {\n      type = \"epson\";\n    } else if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 8) === \"FUJIFILM\") {\n      type = \"fujifilm\";\n    } else if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 9) === \"Panasonic\") {\n      type = \"panasonic\";\n    } else if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 5) === \"SANYO\") {\n      type = \"sanyo\";\n    }\n\n    debug(\"Makernote IFD ifdOffset=\", ifdOffset, \"type=\", type);\n\n    if (type) {\n      var extractMakernotes = require('./makernotes/' + type).extractMakernotes;\n\n      exifData.makernote = extractMakernotes.call(this, data, this.makernoteOffset, tiffOffset);\n    } else {\n      // Makernotes are available but the format is not recognized so\n      // an error message is pushed instead, this ain't the best\n      // solution but should do for now\n      exifData.makernote['error'] = 'Unable to extract Makernote information as it is in an unsupported or unrecognized format.';\n    }\n\n    debug(\"Makernote IFD parsed\", exifData.makernote);\n  }\n};\n\nExifImage.prototype.extractExifEntry = function (data, entryOffset, tiffOffset, isBigEndian, tags) {\n  var entry = {\n    tag: data.slice(entryOffset, entryOffset + 2),\n    tagId: null,\n    tagName: null,\n    format: data.getShort(entryOffset + 2, isBigEndian),\n    components: data.getLong(entryOffset + 4, isBigEndian),\n    valueOffset: null,\n    value: []\n  };\n  entry.tagId = entry.tag.getShort(0, isBigEndian); // The tagId may correspond to more then one tagName so check which\n\n  if (tags && tags[entry.tagId] && typeof tags[entry.tagId] == \"function\") {\n    entry.tagName = tags[entry.tagId].call(this, entry);\n\n    if (!entry.tagName) {\n      return false;\n    } // The tagId corresponds to exactly one tagName\n\n  } else if (tags && tags[entry.tagId]) {\n    entry.tagName = tags[entry.tagId];\n\n    if (entry.tagName === undefined) {\n      return false;\n    } // The tagId is not recognized\n\n  } else {\n    return false;\n  }\n\n  switch (entry.format) {\n    case 0x0001:\n      // unsigned byte, 1 byte per component\n      entry.valueOffset = entry.components <= 4 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\n\n      for (var i = 0; i < entry.components; i++) entry.value.push(data.getByte(entry.valueOffset + i));\n\n      break;\n\n    case 0x0002:\n      // ascii strings, 1 byte per component\n      entry.valueOffset = entry.components <= 4 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\n      entry.value = data.getString(entry.valueOffset, entry.components);\n      if (entry.value[entry.value.length - 1] === \"\\u0000\") // Trim null terminated strings\n        entry.value = entry.value.substring(0, entry.value.length - 1);\n      break;\n\n    case 0x0003:\n      // unsigned short, 2 byte per component\n      entry.valueOffset = entry.components <= 2 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\n\n      for (var i = 0; i < entry.components; i++) entry.value.push(data.getShort(entry.valueOffset + i * 2, isBigEndian));\n\n      break;\n\n    case 0x0004:\n      // unsigned long, 4 byte per component\n      entry.valueOffset = entry.components == 1 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\n\n      for (var i = 0; i < entry.components; i++) entry.value.push(data.getLong(entry.valueOffset + i * 4, isBigEndian));\n\n      break;\n\n    case 0x0005:\n      // unsigned rational, 8 byte per component (4 byte numerator and 4 byte denominator)\n      entry.valueOffset = data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\n\n      for (var i = 0; i < entry.components; i++) entry.value.push(data.getLong(entry.valueOffset + i * 8, isBigEndian) / data.getLong(entry.valueOffset + i * 8 + 4, isBigEndian));\n\n      break;\n\n    case 0x0006:\n      // signed byte, 1 byte per component\n      entry.valueOffset = entry.components <= 4 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\n\n      for (var i = 0; i < entry.components; i++) entry.value.push(data.getSignedByte(entry.valueOffset + i));\n\n      break;\n\n    case 0x0007:\n      // undefined, 1 byte per component\n      entry.valueOffset = entry.components <= 4 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\n      entry.value.push(data.slice(entry.valueOffset, entry.valueOffset + entry.components));\n      break;\n\n    case 0x0008:\n      // signed short, 2 byte per component\n      entry.valueOffset = entry.components <= 2 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\n\n      for (var i = 0; i < entry.components; i++) entry.value.push(data.getSignedShort(entry.valueOffset + i * 2, isBigEndian));\n\n      break;\n\n    case 0x0009:\n      // signed long, 4 byte per component\n      entry.valueOffset = entry.components == 1 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\n\n      for (var i = 0; i < entry.components; i++) entry.value.push(data.getSignedLong(entry.valueOffset + i * 4, isBigEndian));\n\n      break;\n\n    case 0x000A:\n      // signed rational, 8 byte per component (4 byte numerator and 4 byte denominator)\n      entry.valueOffset = data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\n\n      for (var i = 0; i < entry.components; i++) entry.value.push(data.getSignedLong(entry.valueOffset + i * 8, isBigEndian) / data.getSignedLong(entry.valueOffset + i * 8 + 4, isBigEndian));\n\n      break;\n\n    default:\n      return false;\n  } // If this is the Makernote tag save its offset for later use\n\n\n  if (entry.tagName === \"MakerNote\") {\n    this.offsets.makernoteOffset = entry.valueOffset;\n  } // If the value array has only one element we don't need an array\n\n\n  if (entry.value.length == 1) {\n    entry.value = entry.value[0];\n  }\n\n  return entry;\n};\n/**\r\n * Comprehensive list of TIFF and Exif tags found on\r\n * http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/EXIF.html\r\n */\n\n\nExifImage.TAGS = {\n  // Exif tags\n  exif: {\n    0x0001: \"InteropIndex\",\n    0x0002: \"InteropVersion\",\n    0x000B: \"ProcessingSoftware\",\n    0x00FE: \"SubfileType\",\n    0x00FF: \"OldSubfileType\",\n    0x0100: \"ImageWidth\",\n    0x0101: \"ImageHeight\",\n    0x0102: \"BitsPerSample\",\n    0x0103: \"Compression\",\n    0x0106: \"PhotometricInterpretation\",\n    0x0107: \"Thresholding\",\n    0x0108: \"CellWidth\",\n    0x0109: \"CellLength\",\n    0x010A: \"FillOrder\",\n    0x010D: \"DocumentName\",\n    0x010E: \"ImageDescription\",\n    0x010F: \"Make\",\n    0x0110: \"Model\",\n    0x0111: \"StripOffsets\",\n    0x0112: \"Orientation\",\n    0x0115: \"SamplesPerPixel\",\n    0x0116: \"RowsPerStrip\",\n    0x0117: \"StripByteCounts\",\n    0x0118: \"MinSampleValue\",\n    0x0119: \"MaxSampleValue\",\n    0x011A: \"XResolution\",\n    0x011B: \"YResolution\",\n    0x011C: \"PlanarConfiguration\",\n    0x011D: \"PageName\",\n    0x011E: \"XPosition\",\n    0x011F: \"YPosition\",\n    0x0120: \"FreeOffsets\",\n    0x0121: \"FreeByteCounts\",\n    0x0122: \"GrayResponseUnit\",\n    0x0123: \"GrayResponseCurve\",\n    0x0124: \"T4Options\",\n    0x0125: \"T6Options\",\n    0x0128: \"ResolutionUnit\",\n    0x0129: \"PageNumber\",\n    0x012C: \"ColorResponseUnit\",\n    0x012D: \"TransferFunction\",\n    0x0131: \"Software\",\n    0x0132: \"ModifyDate\",\n    0x013B: \"Artist\",\n    0x013C: \"HostComputer\",\n    0x013D: \"Predictor\",\n    0x013E: \"WhitePoint\",\n    0x013F: \"PrimaryChromaticities\",\n    0x0140: \"ColorMap\",\n    0x0141: \"HalftoneHints\",\n    0x0142: \"TileWidth\",\n    0x0143: \"TileLength\",\n    0x0144: \"TileOffsets\",\n    0x0145: \"TileByteCounts\",\n    0x0146: \"BadFaxLines\",\n    0x0147: \"CleanFaxData\",\n    0x0148: \"ConsecutiveBadFaxLines\",\n    0x014A: \"SubIFD\",\n    0x014C: \"InkSet\",\n    0x014D: \"InkNames\",\n    0x014E: \"NumberofInks\",\n    0x0150: \"DotRange\",\n    0x0151: \"TargetPrinter\",\n    0x0152: \"ExtraSamples\",\n    0x0153: \"SampleFormat\",\n    0x0154: \"SMinSampleValue\",\n    0x0155: \"SMaxSampleValue\",\n    0x0156: \"TransferRange\",\n    0x0157: \"ClipPath\",\n    0x0158: \"XClipPathUnits\",\n    0x0159: \"YClipPathUnits\",\n    0x015A: \"Indexed\",\n    0x015B: \"JPEGTables\",\n    0x015F: \"OPIProxy\",\n    0x0190: \"GlobalParametersIFD\",\n    0x0191: \"ProfileType\",\n    0x0192: \"FaxProfile\",\n    0x0193: \"CodingMethods\",\n    0x0194: \"VersionYear\",\n    0x0195: \"ModeNumber\",\n    0x01B1: \"Decode\",\n    0x01B2: \"DefaultImageColor\",\n    0x01B3: \"T82Options\",\n    0x01B5: \"JPEGTables\",\n    0x0200: \"JPEGProc\",\n    0x0201: \"ThumbnailOffset\",\n    0x0202: \"ThumbnailLength\",\n    0x0203: \"JPEGRestartInterval\",\n    0x0205: \"JPEGLosslessPredictors\",\n    0x0206: \"JPEGPointTransforms\",\n    0x0207: \"JPEGQTables\",\n    0x0208: \"JPEGDCTables\",\n    0x0209: \"JPEGACTables\",\n    0x0211: \"YCbCrCoefficients\",\n    0x0212: \"YCbCrSubSampling\",\n    0x0213: \"YCbCrPositioning\",\n    0x0214: \"ReferenceBlackWhite\",\n    0x022F: \"StripRowCounts\",\n    0x02BC: \"ApplicationNotes\",\n    0x03E7: \"USPTOMiscellaneous\",\n    0x1000: \"RelatedImageFileFormat\",\n    0x1001: \"RelatedImageWidth\",\n    0x1002: \"RelatedImageHeight\",\n    0x4746: \"Rating\",\n    0x4747: \"XP_DIP_XML\",\n    0x4748: \"StitchInfo\",\n    0x4749: \"RatingPercent\",\n    0x800D: \"ImageID\",\n    0x80A3: \"WangTag1\",\n    0x80A4: \"WangAnnotation\",\n    0x80A5: \"WangTag3\",\n    0x80A6: \"WangTag4\",\n    0x80E3: \"Matteing\",\n    0x80E4: \"DataType\",\n    0x80E5: \"ImageDepth\",\n    0x80E6: \"TileDepth\",\n    0x827D: \"Model2\",\n    0x828D: \"CFARepeatPatternDim\",\n    0x828E: \"CFAPattern2\",\n    0x828F: \"BatteryLevel\",\n    0x8290: \"KodakIFD\",\n    0x8298: \"Copyright\",\n    0x829A: \"ExposureTime\",\n    0x829D: \"FNumber\",\n    0x82A5: \"MDFileTag\",\n    0x82A6: \"MDScalePixel\",\n    0x82A7: \"MDColorTable\",\n    0x82A8: \"MDLabName\",\n    0x82A9: \"MDSampleInfo\",\n    0x82AA: \"MDPrepDate\",\n    0x82AB: \"MDPrepTime\",\n    0x82AC: \"MDFileUnits\",\n    0x830E: \"PixelScale\",\n    0x8335: \"AdventScale\",\n    0x8336: \"AdventRevision\",\n    0x835C: \"UIC1Tag\",\n    0x835D: \"UIC2Tag\",\n    0x835E: \"UIC3Tag\",\n    0x835F: \"UIC4Tag\",\n    0x83BB: \"IPTC-NAA\",\n    0x847E: \"IntergraphPacketData\",\n    0x847F: \"IntergraphFlagRegisters\",\n    0x8480: \"IntergraphMatrix\",\n    0x8481: \"INGRReserved\",\n    0x8482: \"ModelTiePoint\",\n    0x84E0: \"Site\",\n    0x84E1: \"ColorSequence\",\n    0x84E2: \"IT8Header\",\n    0x84E3: \"RasterPadding\",\n    0x84E4: \"BitsPerRunLength\",\n    0x84E5: \"BitsPerExtendedRunLength\",\n    0x84E6: \"ColorTable\",\n    0x84E7: \"ImageColorIndicator\",\n    0x84E8: \"BackgroundColorIndicator\",\n    0x84E9: \"ImageColorValue\",\n    0x84EA: \"BackgroundColorValue\",\n    0x84EB: \"PixelIntensityRange\",\n    0x84EC: \"TransparencyIndicator\",\n    0x84ED: \"ColorCharacterization\",\n    0x84EE: \"HCUsage\",\n    0x84EF: \"TrapIndicator\",\n    0x84F0: \"CMYKEquivalent\",\n    0x8546: \"SEMInfo\",\n    0x8568: \"AFCP_IPTC\",\n    0x85B8: \"PixelMagicJBIGOptions\",\n    0x85D8: \"ModelTransform\",\n    0x8602: \"WB_GRGBLevels\",\n    0x8606: \"LeafData\",\n    0x8649: \"PhotoshopSettings\",\n    0x8769: \"ExifOffset\",\n    0x8773: \"ICC_Profile\",\n    0x877F: \"TIFF_FXExtensions\",\n    0x8780: \"MultiProfiles\",\n    0x8781: \"SharedData\",\n    0x8782: \"T88Options\",\n    0x87AC: \"ImageLayer\",\n    0x87AF: \"GeoTiffDirectory\",\n    0x87B0: \"GeoTiffDoubleParams\",\n    0x87B1: \"GeoTiffAsciiParams\",\n    0x8822: \"ExposureProgram\",\n    0x8824: \"SpectralSensitivity\",\n    0x8825: \"GPSInfo\",\n    0x8827: \"ISO\",\n    0x8828: \"Opto-ElectricConvFactor\",\n    0x8829: \"Interlace\",\n    0x882A: \"TimeZoneOffset\",\n    0x882B: \"SelfTimerMode\",\n    0x8830: \"SensitivityType\",\n    0x8831: \"StandardOutputSensitivity\",\n    0x8832: \"RecommendedExposureIndex\",\n    0x8833: \"ISOSpeed\",\n    0x8834: \"ISOSpeedLatitudeyyy\",\n    0x8835: \"ISOSpeedLatitudezzz\",\n    0x885C: \"FaxRecvParams\",\n    0x885D: \"FaxSubAddress\",\n    0x885E: \"FaxRecvTime\",\n    0x888A: \"LeafSubIFD\",\n    0x9000: \"ExifVersion\",\n    0x9003: \"DateTimeOriginal\",\n    0x9004: \"CreateDate\",\n    0x9101: \"ComponentsConfiguration\",\n    0x9102: \"CompressedBitsPerPixel\",\n    0x9201: \"ShutterSpeedValue\",\n    0x9202: \"ApertureValue\",\n    0x9203: \"BrightnessValue\",\n    0x9204: \"ExposureCompensation\",\n    0x9205: \"MaxApertureValue\",\n    0x9206: \"SubjectDistance\",\n    0x9207: \"MeteringMode\",\n    0x9208: \"LightSource\",\n    0x9209: \"Flash\",\n    0x920A: \"FocalLength\",\n    0x920B: \"FlashEnergy\",\n    0x920C: \"SpatialFrequencyResponse\",\n    0x920D: \"Noise\",\n    0x920E: \"FocalPlaneXResolution\",\n    0x920F: \"FocalPlaneYResolution\",\n    0x9210: \"FocalPlaneResolutionUnit\",\n    0x9211: \"ImageNumber\",\n    0x9212: \"SecurityClassification\",\n    0x9213: \"ImageHistory\",\n    0x9214: \"SubjectArea\",\n    0x9215: \"ExposureIndex\",\n    0x9216: \"TIFF-EPStandardID\",\n    0x9217: \"SensingMethod\",\n    0x923A: \"CIP3DataFile\",\n    0x923B: \"CIP3Sheet\",\n    0x923C: \"CIP3Side\",\n    0x923F: \"StoNits\",\n    0x927C: \"MakerNote\",\n    0x9286: \"UserComment\",\n    0x9290: \"SubSecTime\",\n    0x9291: \"SubSecTimeOriginal\",\n    0x9292: \"SubSecTimeDigitized\",\n    0x932F: \"MSDocumentText\",\n    0x9330: \"MSPropertySetStorage\",\n    0x9331: \"MSDocumentTextPosition\",\n    0x935C: \"ImageSourceData\",\n    0x9C9B: \"XPTitle\",\n    0x9C9C: \"XPComment\",\n    0x9C9D: \"XPAuthor\",\n    0x9C9E: \"XPKeywords\",\n    0x9C9F: \"XPSubject\",\n    0xA000: \"FlashpixVersion\",\n    0xA001: \"ColorSpace\",\n    0xA002: \"ExifImageWidth\",\n    0xA003: \"ExifImageHeight\",\n    0xA004: \"RelatedSoundFile\",\n    0xA005: \"InteropOffset\",\n    0xA20B: \"FlashEnergy\",\n    0xA20C: \"SpatialFrequencyResponse\",\n    0xA20D: \"Noise\",\n    0xA20E: \"FocalPlaneXResolution\",\n    0xA20F: \"FocalPlaneYResolution\",\n    0xA210: \"FocalPlaneResolutionUnit\",\n    0xA211: \"ImageNumber\",\n    0xA212: \"SecurityClassification\",\n    0xA213: \"ImageHistory\",\n    0xA214: \"SubjectLocation\",\n    0xA215: \"ExposureIndex\",\n    0xA216: \"TIFF-EPStandardID\",\n    0xA217: \"SensingMethod\",\n    0xA300: \"FileSource\",\n    0xA301: \"SceneType\",\n    0xA302: \"CFAPattern\",\n    0xA401: \"CustomRendered\",\n    0xA402: \"ExposureMode\",\n    0xA403: \"WhiteBalance\",\n    0xA404: \"DigitalZoomRatio\",\n    0xA405: \"FocalLengthIn35mmFormat\",\n    0xA406: \"SceneCaptureType\",\n    0xA407: \"GainControl\",\n    0xA408: \"Contrast\",\n    0xA409: \"Saturation\",\n    0xA40A: \"Sharpness\",\n    0xA40B: \"DeviceSettingDescription\",\n    0xA40C: \"SubjectDistanceRange\",\n    0xA420: \"ImageUniqueID\",\n    0xA430: \"OwnerName\",\n    0xA431: \"SerialNumber\",\n    0xA432: \"LensInfo\",\n    0xA433: \"LensMake\",\n    0xA434: \"LensModel\",\n    0xA435: \"LensSerialNumber\",\n    0xA480: \"GDALMetadata\",\n    0xA481: \"GDALNoData\",\n    0xA500: \"Gamma\",\n    0xAFC0: \"ExpandSoftware\",\n    0xAFC1: \"ExpandLens\",\n    0xAFC2: \"ExpandFilm\",\n    0xAFC3: \"ExpandFilterLens\",\n    0xAFC4: \"ExpandScanner\",\n    0xAFC5: \"ExpandFlashLamp\",\n    0xBC01: \"PixelFormat\",\n    0xBC02: \"Transformation\",\n    0xBC03: \"Uncompressed\",\n    0xBC04: \"ImageType\",\n    0xBC80: \"ImageWidth\",\n    0xBC81: \"ImageHeight\",\n    0xBC82: \"WidthResolution\",\n    0xBC83: \"HeightResolution\",\n    0xBCC0: \"ImageOffset\",\n    0xBCC1: \"ImageByteCount\",\n    0xBCC2: \"AlphaOffset\",\n    0xBCC3: \"AlphaByteCount\",\n    0xBCC4: \"ImageDataDiscard\",\n    0xBCC5: \"AlphaDataDiscard\",\n    0xC427: \"OceScanjobDesc\",\n    0xC428: \"OceApplicationSelector\",\n    0xC429: \"OceIDNumber\",\n    0xC42A: \"OceImageLogic\",\n    0xC44F: \"Annotations\",\n    0xC4A5: \"PrintIM\",\n    0xC580: \"USPTOOriginalContentType\",\n    0xC612: \"DNGVersion\",\n    0xC613: \"DNGBackwardVersion\",\n    0xC614: \"UniqueCameraModel\",\n    0xC615: \"LocalizedCameraModel\",\n    0xC616: \"CFAPlaneColor\",\n    0xC617: \"CFALayout\",\n    0xC618: \"LinearizationTable\",\n    0xC619: \"BlackLevelRepeatDim\",\n    0xC61A: \"BlackLevel\",\n    0xC61B: \"BlackLevelDeltaH\",\n    0xC61C: \"BlackLevelDeltaV\",\n    0xC61D: \"WhiteLevel\",\n    0xC61E: \"DefaultScale\",\n    0xC61F: \"DefaultCropOrigin\",\n    0xC620: \"DefaultCropSize\",\n    0xC621: \"ColorMatrix1\",\n    0xC622: \"ColorMatrix2\",\n    0xC623: \"CameraCalibration1\",\n    0xC624: \"CameraCalibration2\",\n    0xC625: \"ReductionMatrix1\",\n    0xC626: \"ReductionMatrix2\",\n    0xC627: \"AnalogBalance\",\n    0xC628: \"AsShotNeutral\",\n    0xC629: \"AsShotWhiteXY\",\n    0xC62A: \"BaselineExposure\",\n    0xC62B: \"BaselineNoise\",\n    0xC62C: \"BaselineSharpness\",\n    0xC62D: \"BayerGreenSplit\",\n    0xC62E: \"LinearResponseLimit\",\n    0xC62F: \"CameraSerialNumber\",\n    0xC630: \"DNGLensInfo\",\n    0xC631: \"ChromaBlurRadius\",\n    0xC632: \"AntiAliasStrength\",\n    0xC633: \"ShadowScale\",\n    0xC634: \"DNGPrivateData\",\n    0xC635: \"MakerNoteSafety\",\n    0xC640: \"RawImageSegmentation\",\n    0xC65A: \"CalibrationIlluminant1\",\n    0xC65B: \"CalibrationIlluminant2\",\n    0xC65C: \"BestQualityScale\",\n    0xC65D: \"RawDataUniqueID\",\n    0xC660: \"AliasLayerMetadata\",\n    0xC68B: \"OriginalRawFileName\",\n    0xC68C: \"OriginalRawFileData\",\n    0xC68D: \"ActiveArea\",\n    0xC68E: \"MaskedAreas\",\n    0xC68F: \"AsShotICCProfile\",\n    0xC690: \"AsShotPreProfileMatrix\",\n    0xC691: \"CurrentICCProfile\",\n    0xC692: \"CurrentPreProfileMatrix\",\n    0xC6BF: \"ColorimetricReference\",\n    0xC6D2: \"PanasonicTitle\",\n    0xC6D3: \"PanasonicTitle2\",\n    0xC6F3: \"CameraCalibrationSig\",\n    0xC6F4: \"ProfileCalibrationSig\",\n    0xC6F5: \"ProfileIFD\",\n    0xC6F6: \"AsShotProfileName\",\n    0xC6F7: \"NoiseReductionApplied\",\n    0xC6F8: \"ProfileName\",\n    0xC6F9: \"ProfileHueSatMapDims\",\n    0xC6FA: \"ProfileHueSatMapData1\",\n    0xC6FB: \"ProfileHueSatMapData2\",\n    0xC6FC: \"ProfileToneCurve\",\n    0xC6FD: \"ProfileEmbedPolicy\",\n    0xC6FE: \"ProfileCopyright\",\n    0xC714: \"ForwardMatrix1\",\n    0xC715: \"ForwardMatrix2\",\n    0xC716: \"PreviewApplicationName\",\n    0xC717: \"PreviewApplicationVersion\",\n    0xC718: \"PreviewSettingsName\",\n    0xC719: \"PreviewSettingsDigest\",\n    0xC71A: \"PreviewColorSpace\",\n    0xC71B: \"PreviewDateTime\",\n    0xC71C: \"RawImageDigest\",\n    0xC71D: \"OriginalRawFileDigest\",\n    0xC71E: \"SubTileBlockSize\",\n    0xC71F: \"RowInterleaveFactor\",\n    0xC725: \"ProfileLookTableDims\",\n    0xC726: \"ProfileLookTableData\",\n    0xC740: \"OpcodeList1\",\n    0xC741: \"OpcodeList2\",\n    0xC74E: \"OpcodeList3\",\n    0xC761: \"NoiseProfile\",\n    0xC763: \"TimeCodes\",\n    0xC764: \"FrameRate\",\n    0xC772: \"TStop\",\n    0xC789: \"ReelName\",\n    0xC791: \"OriginalDefaultFinalSize\",\n    0xC792: \"OriginalBestQualitySize\",\n    0xC793: \"OriginalDefaultCropSize\",\n    0xC7A1: \"CameraLabel\",\n    0xC7A3: \"ProfileHueSatMapEncoding\",\n    0xC7A4: \"ProfileLookTableEncoding\",\n    0xC7A5: \"BaselineExposureOffset\",\n    0xC7A6: \"DefaultBlackRender\",\n    0xC7A7: \"NewRawImageDigest\",\n    0xC7A8: \"RawToPreviewGain\",\n    0xC7B5: \"DefaultUserCrop\",\n    0xEA1C: \"Padding\",\n    0xEA1D: \"OffsetSchema\",\n    0xFDE8: \"OwnerName\",\n    0xFDE9: \"SerialNumber\",\n    0xFDEA: \"Lens\",\n    0xFE00: \"KDC_IFD\",\n    0xFE4C: \"RawFile\",\n    0xFE4D: \"Converter\",\n    0xFE4E: \"WhiteBalance\",\n    0xFE51: \"Exposure\",\n    0xFE52: \"Shadows\",\n    0xFE53: \"Brightness\",\n    0xFE54: \"Contrast\",\n    0xFE55: \"Saturation\",\n    0xFE56: \"Sharpness\",\n    0xFE57: \"Smoothness\",\n    0xFE58: \"MoireFilter\"\n  },\n  // GPS Tags\n  gps: {\n    0x0000: 'GPSVersionID',\n    0x0001: 'GPSLatitudeRef',\n    0x0002: 'GPSLatitude',\n    0x0003: 'GPSLongitudeRef',\n    0x0004: 'GPSLongitude',\n    0x0005: 'GPSAltitudeRef',\n    0x0006: 'GPSAltitude',\n    0x0007: 'GPSTimeStamp',\n    0x0008: 'GPSSatellites',\n    0x0009: 'GPSStatus',\n    0x000A: 'GPSMeasureMode',\n    0x000B: 'GPSDOP',\n    0x000C: 'GPSSpeedRef',\n    0x000D: 'GPSSpeed',\n    0x000E: 'GPSTrackRef',\n    0x000F: 'GPSTrack',\n    0x0010: 'GPSImgDirectionRef',\n    0x0011: 'GPSImgDirection',\n    0x0012: 'GPSMapDatum',\n    0x0013: 'GPSDestLatitudeRef',\n    0x0014: 'GPSDestLatitude',\n    0x0015: 'GPSDestLongitudeRef',\n    0x0016: 'GPSDestLongitude',\n    0x0017: 'GPSDestBearingRef',\n    0x0018: 'GPSDestBearing',\n    0x0019: 'GPSDestDistanceRef',\n    0x001A: 'GPSDestDistance',\n    0x001B: 'GPSProcessingMethod',\n    0x001C: 'GPSAreaInformation',\n    0x001D: 'GPSDateStamp',\n    0x001E: 'GPSDifferential',\n    0x001F: 'GPSHPositioningError'\n  }\n};","map":null,"metadata":{},"sourceType":"script"}